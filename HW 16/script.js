'use strict';

// first
console.log('start'); // start - виведеться в першу чергу, т.я. js оброблює код послідовно 

const promise1 = new Promise((resolve, reject) => {
console.log(1) // 1 - виведеться другим, одразу після створення проміса, бо всередині проміса код виконується синхронно
resolve(2) // 2 - виведеться останнім, після того, як викличеться .then, тобто після успішного виконання промісу
})

promise1.then(res => {
console.log(res)
})

console.log('end'); // end - виведеться третім, т.я. йде одразу після сторення промісу без очікування його вирішення

//second
Promise.resolve(1)  // проміс успішно вирішується значенням 1
		.then((x) => x + 1) // x = 2, т.я. до попередьного результату (1) додаємо 1
		.then((x) => { throw new Error('My Error') }) // обробник видає помилку
		.catch(() => 1) // спрацьовує .catch, т.я. до цього виникла помилка. повертається новий проміс зі значенням 1
		.then((x) => x + 1) // до попереднього значення додається 1, тепер х = 2
		.then((x) => console.log(x)) // т.я. х = 2, то в консолі виведеться 2
		.catch(console.error) // не виконається, т.я. після першого catch не було помилок

//third
const promise = new Promise(res => res(2)); // створюється проміс, який успішно вирішується значенням 2
	promise.then(v => {
	        console.log(v); // 2 - обробник отримує попереднє значення і виводить його в консоль
	        return v * 2; // повертається проміс з новим значенням - 4 (результат 2 * 2)
	    })
	    .then(v => {
	        console.log(v); // 4 - обробник отримує попереднє значення з then і виводить його в консоль
	        return v * 2; // повертається проміс з новим значенням - 8 (результат 4 * 2)
	    })
	    .finally(v => {  // finally не оброблює результати з then, і в даному випадку v невизначено
	        console.log(v); // у консолі виведеться undefined
	        return v * 2;
	    })
	    .then(v => {
	        console.log(v); // 8 - обробник отримує попереднє значення з then і виводить його в консоль
	    });